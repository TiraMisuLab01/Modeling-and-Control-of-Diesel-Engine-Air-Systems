# 项目核心：柴油机空气系统的多变量控制

这个项目的核心是控制一个2输入2输出（MIMO）的线性系统。

* 系统: 柴油发动机空气系统。
* 输入 (u):
  1. u1: VGT（可变几何涡轮）的叶片位置
  2. u2: EGR（废气再循环）的阀门位置
* 输出 (y):
  1. y1: 缸内空燃比 (AFR)<mark></mark>
  2. y2: 进气歧管EGR百分比
* 模型: 项目提供了一个四阶的状态空间模型 (ẋ = Ax + Bu, y = Cx)，其中的 A, B, C 矩阵参数取决于您学号的后四位数字 (a = 8, b = 4, c = 0, d = 1)。

物理系统本身（如图2所示）存在显著的**耦合**：调整VGT不仅会改变空气流量（影响AFR），也会改变排气背压，从而影响EGR的流量；同样，调整EGR阀门也会反过来影响到整个系统的气流动态。因此，这个项目本质上是一个典型的**解耦控制**问题，并在此基础上考察了现代控制理论中的多种核心设计方法。

## 设计规范

状态空间模型(1)中所有输出y的瞬态阶跃响应性能规范如下：

1) 超调量小于10%。

2) 2%沉降时间小于20秒。

注：(a)通过为每个输入通道施加阶跃参考信号（即[1,0]和[0,1]），在初始条件为零的情

况下验证瞬态响应；(b)对于后续任务1)至5)，您的控制系统需满足该性能规范，并完成每个

任务的必要研究。

---

## 各任务的详细分析与理论关联

我们正在控制一个柴油发动机的空气系统。这个系统的目标是<mark>精确控制进入气缸的空燃比(AFR)和废气再循环率(EGR)</mark>。

* 为什么需要控制？ 为了满足日益严格的排放法规（减少NOx和PM），同时还要保证发动机的性能和燃油经济性。

* <mark>如何控制？ 通过调节两个主要的执行器：VGT（可变几何涡轮）和EGR阀</mark>。
  这个控制问题很复杂，因为<mark>VGT和EGR的调节是相互影响（耦合）</mark>的。例如，调节VGT会影响EGR，反之亦然。直接手动调节或者用简单的单回路控制器效果很差
  。因此，我们需要一个“聪明”的控制器，也就是我们正在设计的状态反馈控制器，来同时协调这两个执行器，让AFR和EGR两个输出都达到我们想要的目标值。

* <mark>任务1“所有四个状态变量”是哪四个？</mark>
  这是最让人困惑的地方，也是理论模型和物理现实的一个关键区别。
  
  * 物理上，发动机系统里有许多物理量，比如涡轮转速、进气压力、温度等等。
  
  * 模型上，项目文件（Page 3-4）明确指出，我们使用的这个状态空间模型 (ẋ = Ax + Bu) 是通过系统辨识的方法从实验数据中得到的。
    这意味着：这<mark>四个状态变量 `x1, x2, x3, x4`</mark> 并没有直接、明确的物理意义。
    它们不是像“涡轮转速”或“进气压力”这样可以直接测量的物理量。它们是数学模型在拟合真实系统动态时，内部产生的一组中间变量。
    这在工程上很常见。
    只要这个数学模型能够准确地描述“我们操作输入（VGT/EGR）”和“我们关心的输出（AFR/EGR率）”之间的关系，那么这个模型就是有用的。
    
    

---

## **任务 1: 极点配置状态反馈控制器**

任务要求原文：

Assume that you can measure all the four state variables, design a state feedback controller using the pole place method, simulate the designed system, check the step responses and show all the four state responses to non-zero initial state with zero external inputs. Discuss effects of the positions of the poles on system performance, and also monitor control signal size. In this step, both the disturbance and set point can be assumed to be zero. (15 points)

> * **<mark>任务1的设计是在设计什么？</mark>**
>   一句话总结：任务1是在设计一个“大脑”（控制器），这个大脑通过读取发动机的（假想的）内部状态，来决定如何精细地调节VGT和EGR，从而让整个发动机 系统的响应变得又快又稳。 我们通过“极点配置”来实现这个目标。
> 
> * 什么是“极点”？
>   您可以把它理解为决定一个系统动态特性的“基因”。极点的位置决定了系统在受到扰动后，是会快速稳定下来、缓慢摇晃、还是会发散崩溃。
> 
> * 什么是“极点配置”？ 
>   我们通过设计反馈矩阵 K，可以人为地、随心所欲地移动闭环系统的极点到S平面的任何我们想要的位置。
> 
> * **<mark>为什么要做这个？</mark>**
>   
>   1. 保证稳定：原始的发动机系统（开环系统）可能不稳定或响应很差。通过状态反馈，我们可以把所有极点都移动到S平面的左半边，确保系统绝对稳定。
>   2. 提升性能：我们可以把极点放置在能满足“稳定时间<5秒，超调<10%”这些具体指标的“最佳位置”。比如，把极点放在离虚轴远一点的地方，响应就会更快（稳定时间短）；调整极点的虚部和实部之比，就可以控制超调。
>   
>   <mark>**所以，任务1的完整逻辑链是：**</mark>
> 1. 对象：一个用A, B, C矩阵描述的柴油机空气系统数学模型。
> 2. 目标：让这个系统的动态响应满足给定的性能指标（快、稳、准）。
> 3. 手段：设计一个状态反馈控制器 <mark>u = -Kx</mark>。
> 4. 核心技术：使用极点配置法来计算出能实现我们目标的反馈矩阵 K。
> 5. 验证：在MATLAB/Simulink中仿真，看看加上我们设计的控制器后，系统的表现是否真的如我们所愿。同时观察控制信号 u (即VGT和EGR的调节指令)
> - <mark>**为什么任务1是 `u = -Kx` 而不是 `u = -Kx + Fr`？**</mark>
>   这主要是由任务1的具体要求决定的，并且有充分的理论支撑。
> 1. 任务1的目标是“调节问题”（Regulation Problem）：
>    
>    * 请回顾任务1的描述：“假设可以测量所有四个状态变量，使用极点位置法设计状态反馈控制器，对设计的系统
>      进行仿真，检查阶跃响应，并显示所有四个状态在非零初始状态和零外部输入下的响
>      应。讨论极点位置对系统性能的影响，并监测控制信号的幅值。<mark>在此步骤中，扰动和设定值可以假设为零。</mark>”
>    
>    * 当“设定值”（reference input）r 为零时，控制律 u = -Kx + Fr 自然就简化为 u = -Kx。
>    
>    * 调节问题的目标是将系统状态从非零初始条件（例如 $x_0 = [0.5, -0.1, 0.3,
>      -0.8]^T$）或在扰动下，稳定地带回到原点（零状态）。在这种情况下，我们不需要一个 Fr 项来跟踪一个非零的设定值。<mark>K矩阵的作用就是通过改变系统极点，确保系统能够稳定地回到原点，并具有期望的瞬态响应</mark>。
> 
> 2. <mark>`Fr` 项的作用是“跟踪设定值”（Tracking/Servo Control）：</mark>
>    
>    * 第7章（Pole Placement）的Page 2，公式(2)明确给出了更一般的状态反馈控制律：u = -Kx + Fr。<img title="" src="file:///C:/Users/16612/Pictures/Typedown/5b5fb582-3c0f-4db9-892f-dfd8386b8ece.png" alt="5b5fb582-3c0f-4db9-892f-dfd8386b8ece" data-align="center" style="zoom:80%;">
>    * 这里的 r 是参考输入或设定值，F 是前馈增益。Fr 项的作用是确保当 r 不为零时，系统的输出能够准确地跟踪这个设定值，并且通常能消除稳态误差。
>    * 在任务5中，您会看到我们确实需要处理一个非零的设定点 ($y_{sp} = [0.4, 0.8]^T$)，并且需要抑制扰动。那将是一个典型的伺服控制问题，届时 Fr
>      项（或其等效的积分控制结构）就会变得非常重要。
>      3* **<mark>知识支撑</mark>**
> * 第7章 §7.1 State Feedback (Page 1-2)：
>   
>   * Page 1给出了开环系统 ẋ = Ax + Bu。
>   * Page 2，公式(2)给出了一般形式的状态反馈控制律 u = -Kx + Fr。
>   * Page 2，公式(3a)展示了应用此控制律后，闭环系统的动态方程为 ẋ = (A-BK)x + BFr。
>   * 当 r=0 时，闭环系统变为 ẋ = (A-BK)x。此时，K 矩阵通过改变 A 矩阵的特征值（极点），来影响系统的稳定性和瞬态响应。
>   
>   所以，任务1的设计目标是在没有外部设定值输入的情况下，通过状态反馈 `u = -Kx`
>   来重新配置系统的极点，从而改善其从任意初始状态到零状态的瞬态响应性能。这正是极点配置技术最直接的应用场景之一。

* **要求**: 设计一个状态反馈控制器 u = -Kx，使得闭环系统在零设定值和零扰动下，从非零初始状态出发，其输出 y 的瞬态响应满足：超调量 M_p < 10% 且
    2%稳定时间 t_s < 5秒。同时，需要观察所有状态的响应和控制信号的幅值。

* **理论关联**: 这完全对应**第7章 (Chapter 7: Pole Placement)** 的内容。

### **步骤一：系统矩阵的确定与可控性检验**

1. 确定系统矩阵 (A, B, C)：
   
   * 思路：首先，根据您提供的学号参数 a=8, b=4, c=0, d=1，将其代入项目文件（Page 3，公式2）中给出的 A, B, C 矩阵的表达式。<img src="file:///C:/Users/16612/Pictures/Typedown/88439fcc-dad9-4669-b30d-36067e2e8ad9.png" title="" alt="88439fcc-dad9-4669-b30d-36067e2e8ad9" data-align="center">
   * 推理：这是所有后续计算的基础。精确的数值矩阵是进行控制系统设计的第一步。
   * 程序运行结果：<img src="file:///C:/Users/16612/Pictures/Typedown/c9eb78b9-a368-41a8-86a3-47bec904a97b.png" title="" alt="c9eb78b9-a368-41a8-86a3-47bec904a97b" data-align="center">

2. 检验系统的可控性：
   
   * 思路：构建系统的可控性矩阵 W_c，并计算其秩。
   * 推理：根据第7章（Page 21，定理1 / Slide Page），系统能够通过状态反馈任意配置极点的充要条件是系统是可控的。如果系统不可控，那么我们将无法将所有极点移动到我们期望的位置，任务目标就无法实现。<img title="" src="file:///C:/Users/16612/Pictures/Typedown/313ac84e-18a9-4f46-bc3e-d90af025357b.png" alt="313ac84e-18a9-4f46-bc3e-d90af025357b" data-align="center" style="zoom:67%;">
   * 方法：
     * 系统是4阶的（n=4），有2个输入（m=2）。
     * 可控性矩阵 W_c 的定义为 $W_c = [B, AB, A^2B, A^3B]$。这将是一个 n x (n*m)，即 4 x 8 的矩阵。
     * 计算 W_c 的秩。如果 $rank(W_c) = n$（即 $rank(W_c) = 4$），则系统可控。
   
   > <img title="" src="file:///C:/Users/16612/Pictures/Typedown/3d02153e-f025-4463-aba5-ff8396706429.png" alt="3d02153e-f025-4463-aba5-ff8396706429" data-align="left">
   
   ### **步骤二：确定期望的闭环极点位置**

3. 将性能指标转换为S平面区域：
   
   * 思路：利用二阶系统近似公式，将超调量和稳定时间的要求转换为S平面上极点必须满足的区域。
   * 推理：第7章（Page 11）提供了这些公式，它们是连接时域性能和频域（极点位置）特性的桥梁。<img title="" src="file:///C:/Users/16612/Pictures/Typedown/9d58ee28-f75e-4a09-9635-4fcf3ed58279.png" alt="9d58ee28-f75e-4a09-9635-4fcf3ed58279" data-align="center" style="zoom:67%;"><img title="" src="file:///C:/Users/16612/Pictures/Typedown/4418a3d3-517d-4fa8-afd6-d08607db1146.png" alt="4418a3d3-517d-4fa8-afd6-d08607db1146" data-align="center" style="zoom:67%;">
   * 方法：
     * 超调量 `M_p < 10%`：根据公式 $M_p = exp(-πζ / sqrt(1-ζ^2))$，解出 ζ（阻尼比）需要满足 ζ >0.59。这在S平面上对应一个以原点为顶点的锥形区域。
     * 2%稳定时间 `t_s < 5秒`：根据公式 t_s ≈ 4/(ζωn)，解出 ζωn（极点实部）需要满足 ζωn >0.8。这在S平面上对应一条垂直线，所有极点必须位于这条线的左侧。
     * 代码结果：![a2204c41-f3e2-499a-9526-0512a55161f1](file:///C:/Users/16612/Pictures/Typedown/a2204c41-f3e2-499a-9526-0512a55161f1.png)
   
   >  <mark>实数极点与复数极点的区别</mark>
   > 
   > * 复数共轭极点：通常会导致系统响应出现振荡（超调），但如果阻尼比设计得当，可以实现较快的响应速度。它们由阻尼比 ζ 和自然频率 ωn 共同决定。
   > 
   > * 实数极点：会导致系统响应不振荡（无超调）。所有实数极点都会使系统处于过阻尼或临界阻尼状态，从而消除超调。响应速度由极点距离虚轴的远近（实部大小）决定，越负的实数极点，对应的响应模式衰减越快。
   >   根据项目要求：
   > 
   > * 超调量 Mp < 10% (要求 ζ > 0.591)
   > 
   > * 2%稳定时间 ts < 5秒 (要求 ζωn > 0.8)
   >   我为您建议以下四组期望的闭环极点 P_desired：
   > 1. `λ1,2 = -1.5 ± 1.5j` (主导复数共轭极点)
   >    
   >    * 理由：
   >      * 实部：Re(λ) = -1.5。对应的 ζωn = 1.5，大于 0.8，满足稳定时间要求。
   >      * 自然频率：$ω_n = sqrt((-1.5)^2 + (1.5)^2) ≈ 2.121 rad/s$。
   >      * 阻尼比：ζ = 1.5 / 2.121 ≈ 0.707。由于 0.707 大于 0.591，这满足了超调量小于10%的要求（实际超调量约为4.3%）。
   >      * 这对极点将提供一个具有适度超调的快速响应，通常能带来较好的上升时间。
   > 
   > 2. `λ3 = -5.0` (非主导实数极点)
   >    
   >    * 理由：一个较快的实数极点。其实部 |-5.0| = 5.0 远大于 0.8，且大约是主导极点实部 |-1.5|
   >      的3倍快。这确保了由该极点引起的响应模式会迅速衰减，不会对系统的主要动态产生显著影响。
   > 
   > 3. `λ4 = -6.0` (非主导实数极点)
   >    
   >    * 理由：最快的实数极点。其实部 |-6.0| = 6.0 远大于 0.8，且大约是主导极点实部 |-1.5|
   >      的4倍快。它将确保其对应的模式衰减最快，对系统响应的影响最小。
   >    
   >    最终建议的期望闭环极点集合为：
   >    P_desired = [-1.5 + 1.5j, -1.5 - 1.5j, -5.0, -6.0]

4. 选择四组期望的闭环极点 `P_desired`：
   
   * 思路：根据上述S平面区域的约束，选择两对共轭复数极点或四个实数极点（或混合），确保它们满足性能要求。
   * 推理：对于四阶系统，我们需要选择四个极点。通常会选择一对“主导极点”（dominant poles），它们决定了系统的主要响应特性，并将其放置在满足
     M_p 和 t_s 约束的边界附近。其余的“非主导极点”则选择得比主导极点更快（实部更负，通常是3-5倍），以确保它们对系统响应的影响较小。
   * 考虑因素：在选择极点时，还需要考虑控制信号的幅值。将极点放置得过于靠左（响应过快）可能会导致控制器输出过大，在实际系统中可能无法实现
   
   ### **步骤三：计算反馈增益矩阵 K (使用单位秩方法 Unity Rank K)**

5. 选择权重向量 `q`：
   
   * 思路：选择一个 m x 1（即 2 x 1）的非零向量 q，使得 (A, Bq) 对是可控的。
   
   * 推理：第7章 §7.4.1 Unity Rank K (Page 50-56) 介绍了单位秩方法。它通过将多输入系统 (A, B) 转换为一个等效的单输入系统 (A,Bq)，从而可以使用单输入系统的极点配置方法来求解。选择 q 的目的是确保这个等效的单输入系统仍然可控。<img title="" src="file:///C:/Users/16612/Pictures/Typedown/cf115148-6132-4633-a797-3e0f008f69a1.png" alt="cf115148-6132-4633-a797-3e0f008f69a1" data-align="center" style="zoom:80%;"><img src="file:///C:/Users/16612/Pictures/Typedown/4ec5ecad-389f-4e8e-82f2-8e9b5d496511.png" title="" alt="4ec5ecad-389f-4e8e-82f2-8e9b5d496511" style="zoom:80%;">
   
   * 方法：可以尝试简单的 q 向量，例如<mark> [1; 0] 或 [0; 1] 或 [1; 1]</mark>。对于每个 q，都需要检验 (A, Bq) 的可控性，即计算 $rank([Bq, A*Bq, A^2*Bq,
      A^3*Bq])$ 是否为4。
      x是四维（四个状态变量），那么q向量不应该也是四维吗?
     
     > 1. `q` 向量是用来组合系统输入的：
     > * 在单位秩方法 (Unity Rank Method)中，我们的核心思想是将多输入系统（MIMO）等效为一个单输入系统（SISO）。
     > 
     > * 原始系统有 m 个输入。在我们的发动机项目中，m=2（VGT和EGR阀门位置），所以<mark>输入 u 是一个 2 x 1 的向量</mark>。
     > 
     > * 我们引入一个新的标量输入 v。
     > 
     > * 然后，我们定义 u = q * v。
     > 
     > * <mark>为了让 u（2 x 1）等于 q 乘以 v（1 x 1），那么 q 必须是一个 2 x 1 的向量</mark>。
     > 2. 系统方程的转换：
     >    
     >    * 原始系统方程是 ẋ = Ax + Bu。
     >    * 当我们用 u = qv 代替 u 时，方程变为 ẋ = Ax + B(qv) = Ax + (Bq)v。
     >    * 现在，Bq 成为新的输入矩阵，而 v 是新的标量输入。
     >    * <mark>B 是 n x m 矩阵（4 x 2）。</mark>
     >    * <mark>q 是 m x 1 向量（2 x 1）。</mark>
     >    * 所以，Bq 的结果是一个 n x 1 向量（4 x 1）。这个 4 x 1 的向量就是我们等效的单输入系统中的 b_new 向量。
     > 
     > 3. 可控性检验的维度：
     >    
     >    * 对于这个等效的单输入系统 (A, Bq)，其可控性矩阵是 [Bq, A*Bq, A^2*Bq, A^3*Bq]。
     >    * Bq 是 4 x 1 的向量。
     >    * A*Bq 也是 4 x 1 的向量。
     >    * 因此，可控性矩阵 [Bq, A*Bq, A^2*Bq, A^3*Bq] 是一个 4 x 4 的方阵。我们检验它的秩是否为 n=4。
     > 
     > 总结：q 向量的维度取决于系统输入的数量 `m`，而不是状态变量的数量 n。在我们的项目中，m=2，所以 q是一个2维向量。它起到了将多个输入“加权组合”成一个单一输入的作用，从而将多输入系统转化为单输入系统进行极点配置。

6. 计算等效单输入反馈增益 `k_siso`：
   
   * 思路：对可控的单输入系统 (A, Bq)，计算一个 1 x n（即 1 x 4）的反馈增益向量 k_siso，使得 eig(A - Bq * k_siso) = P_desired。
     
     > 核心是求解一个线性代数问题，使得闭环系统的特征多项式与我们期望的特征多项式完全一致。第7章（Pole
     >   Placement）详细介绍了如何实现这一点。
     >   对于一个可控的单输入系统 (A, Bq)，我们希望找到一个 1 x n 的反馈增益向量 k_siso，使得闭环系统 $(A - Bq * k_{siso}^T)$
     >   的特征值（极点）是我们预先设定的 P_desired。
     >   在第7章 §7.3 Single-input Case (Page 20-34) 中，有两种主要的方法可以实现：
     > 
     > 1. 直接比较法 (Direct Comparison Method)：
     >    
     >    * 思路：这种方法基于闭环系统的特征多项式 det(sI - (A - Bq * k_siso^T)) 必须等于我们期望的特征多项式 φ_d(s)。
     >    * 步骤：
     >      1. 首先，计算出闭环系统矩阵 A_cl = A - Bq * k_siso^T。请注意，k_siso^T 是一个行向量，Bq 是一个列向量，它们的乘积 Bq * k_siso^T
     >         是一个 n x n 的矩阵。
     >      2. 然后，计算 det(sI - A_cl)，这将得到一个以 s 为变量，且系数中包含 k_siso 各元素的 n 阶多项式。
     >      3. 同时，根据我们选择的期望极点 P_desired，构建期望的特征多项式 φ_d(s) = (s - λ1)(s - λ2)...(s - λn)。
     >      4. 最后，比较这两个多项式中 s 的同次幂项的系数。这将得到一个包含 n 个线性方程的方程组，未知数就是 k_siso 的 n
     >         个元素。解这个方程组即可得到 k_siso。
     >    * 局限性：第7章（Page 29）指出，当系统阶数 n 较高（例如 n=4）时，手动展开行列式并求解方程组会非常繁琐和困难。
     > 
     > 2. Ackermann 公式 (Ackermann's Formula)：
     >    
     >    * 思路：这是一种更系统化、更直接的方法，尤其适用于高阶系统。
     >    * 公式：第7章（Page 30）给出了Ackermann公式：
     >      $k_{siso}^T = [0, 0, ..., 0, 1] * Wc_{siso}^{-1} * φ_d(A)$![f6af5eeb-ca2c-4523-b551-e8c57c146fbe](file:///C:/Users/16612/Pictures/Typedown/f6af5eeb-ca2c-4523-b551-e8c57c146fbe.png)
     >    * 步骤：
     >      1. 计算 `Wc_siso`：这是针对单输入系统 (A, Bq) 的可控性矩阵，即 Wc_siso = [Bq, A*Bq, A^2*Bq, A^3*Bq]。
     >      2. 计算 `Wc_siso^(-1)`：求出 Wc_siso 的逆矩阵。
     >      3. 计算 `φ_d(A)`：将期望的特征多项式 φ_d(s) 中的 s 替换为矩阵 A，常数项替换为 I（单位矩阵）。例如，如果 φ_d(s) = s^n + γ_(n-1)s^(n-1) + ... + γ_1s + γ_0，那么 φ_d(A) = A^n + γ_(n-1)A^(n-1) + ... + γ_1A + γ_0I。
     >      4. 代入公式：将上述结果代入Ackermann公式，即可直接计算出 k_siso^T。
     >    * 优点：这种方法避免了复杂的方程组求解，直接给出了 k_siso。
     >    
     >    总结：
     >    在实际操作中，尤其是对于4阶系统，我们通常会选择使用Ackermann公式，因为它更具通用性和计算效率。当然，在MATLAB等工具中，这些计算都已经被封装
     >    在 place 或 acker 等函数中，我们只需提供 A、Bq 和 P_desired 即可直接获得 k_siso。
   
   * 推理：一旦将MIMO问题转化为SISO问题，就可以使用成熟的SISO极点配置算法（如Ackermann公式或MATLAB的 place 函数）来计算 k_siso。

7. 构建最终的MIMO反馈增益矩阵 `K`：
   
   * 思路：将 q 和 k_siso 组合，得到 m x n（即 2 x 4）的 K 矩阵。
   * 推理：根据第7章（Page 56，公式12），最终的反馈增益矩阵 K 为 K = q * k_siso。<img title="" src="file:///C:/Users/16612/Pictures/Typedown/3c5c2e37-e795-46f0-83e7-185fd98e6d50.png" alt="3c5c2e37-e795-46f0-83e7-185fd98e6d50" data-align="center" style="zoom:80%;">
   
   <img src="file:///C:/Users/16612/Pictures/Typedown/d8982a5f-56a6-49b2-8c4a-2da562687c8f.png" title="" alt="d8982a5f-56a6-49b2-8c4a-2da562687c8f" data-align="center">
   
   ### **步骤四：仿真与性能分析**

8. 构建闭环系统模型：
   
   * 思路：使用计算出的 K 矩阵，构建闭环状态空间模型 sys_cl = ss(A-BK, B, C, 0)。
     
     > <mark>详细解释一下“构建闭环系统模型 sys_cl = ss(A-BK, B, C, 0)”这一步的含义。</mark>
     >   理解闭环系统模型 `sys_cl = ss(A-BK, B, C, 0)`
     >   我们从原始的开环系统和您设计的控制律开始：
     > 
     > 1. 原始开环系统：
     >    
     >    * 状态方程：ẋ = Ax + Bu
     >    * 输出方程：y = Cx + Du (在我们的项目中，D 矩阵为零，所以 y = Cx)
     > 
     > 2. 任务1的控制律：
     >    
     >    * u = -Kx (因为任务1假设设定值 r=0，所以 Fr 项为零)
     >    
     >    现在，我们将控制律 u = -Kx 代入原始系统的状态方程：
     > * ẋ = Ax + B(-Kx)
     > 
     > * ẋ = Ax - BKx
     > 
     > * ẋ = (A - BK)x
     >   这就是闭环系统的状态方程。它描述了在状态反馈控制器作用下，系统状态 x 如何随时间演变。
     > 
     > * 新的系统矩阵：A_cl = (A - BK)。这是闭环系统最核心的变化，它决定了闭环系统的极点位置和动态特性。
     > 
     > * 输出矩阵：C_cl = C。输出方程没有改变。
     > 
     > * 直通矩阵：D_cl = 0。直通矩阵也没有改变。
     >   关于 `B` 矩阵的含义
     >   现在，关键在于 ss(A_cl, B_cl, C_cl, D_cl) 中的 B_cl 应该是什么。
     > 1. 对于“非零初始状态和零外部输入下的响应”：
     >    
     >    * 如果严格按照 u = -Kx 且没有外部输入（即 r=0），那么闭环系统是 ẋ = (A - BK)x。
     >    * 在这种情况下，闭环系统没有外部输入。在MATLAB中，通常会用 ss(A_cl, [], C_cl, []) 或 ss(A_cl, zeros(n,0), C_cl, zeros(p,0))
     >      来表示一个没有输入的系统，只用于仿真初始条件响应。
     > 
     > 2. 对于“检查阶跃响应”：
     >    
     >    * 任务1虽然假设“设定值可以假设为零”，但同时又要求“检查阶跃响应”。这通常指的是检查系统对参考输入 `r` 的阶跃变化的响应。
     >    * 为了在闭环系统中引入参考输入 r 进行阶跃响应测试，我们通常会考虑更一般的控制律形式 u = -Kx + Fr。
     >    * 在任务1的语境下，如果 F 没有被明确设计，但我们仍要测试对参考输入 r 的阶跃响应，那么通常会隐式地假设 `F` 为单位矩阵 `I`。
     >    * 在这种情况下，控制律变为 u = -Kx + r。
     >    * 将其代入原始系统状态方程：
     >      * ẋ = Ax + B(-Kx + r)
     >      * ẋ = (A - BK)x + Br
     >    * 此时，闭环系统就有了外部输入 r，其输入矩阵就是原始的 B 矩阵。
     >    
     >    因此，`sys_cl = ss(A-BK, B, C, 0)` 这种写法，是为了在MATLAB中方便地表示一个闭环系统，它允许我们：
     > * 仿真初始条件响应：此时 B 矩阵虽然存在，但外部输入 r 设为零，所以 Br 项为零，系统行为由 (A-BK)x 决定。
     > 
     > * 仿真阶跃响应：此时将阶跃信号作为外部输入 r 施加给系统，通过 Br 项影响状态，从而观察闭环系统对参考输入的跟踪能力（即使在任务1中我们不设计
     >   F 来优化跟踪性能）。
     >   简而言之，A-BK 是闭环系统的核心动态矩阵，而 B 矩阵在这里作为外部参考输入 `r` 进入闭环系统的通道。
   
   * 推理：这是我们设计的控制器作用于原系统后的最终模型，所有性能分析都将基于此模型。

9. 阶跃响应仿真：
   
   * 思路：对闭环系统施加阶跃输入，观察输出 y 和状态 x 的响应。
   * 推理：项目要求检查阶跃响应。由于是MIMO系统，我们需要对每个输入通道单独施加阶跃信号（例如，r = [1; 0] 和 r = [0;1]），并观察所有输出的响应。
   * 分析：检查 y 的响应是否满足 M_p < 10% 和 t_s < 5秒 的要求。

10. 非零初始状态响应仿真：
    
    * 思路：在零外部输入 (r=0) 的情况下，仿真系统从给定的非零初始状态 $x_0 = [0.5, -0.1, 0.3, -0.8]^T$ 出发的响应。
    * 推理：这是调节问题的典型场景，我们需要观察所有四个状态变量 x1, x2, x3, x4 如何随时间变化并收敛到零。

11. 控制信号幅值监测：
    
    * 思路：在上述仿真过程中，记录并分析控制信号 u = -Kx 的幅值。
    * 推理：在实际工程中，执行器（VGT和EGR阀）的输出能力是有限的。如果 u 的幅值过大，超出了执行器的物理限制，那么即使理论上性能再好，这个控
      制器也是不可用的。这可能需要我们重新评估期望的极点位置，在性能和控制成本之间进行权衡。

---

## **任务 2: LQR 最优控制器**

任务原文要求：Assume that you can measure all the four state variables, design a state feedback controller using the LQR method, simulate the designed system, check the step responses and show all the state responses to non-zero initial state with zero external inputs. Discuss effects of weightings Q and R on system performance, and also monitor control signal size. In this step, both the disturbance and set point can be assumed to be zero. (15 points)

* ~~**要求**: 同样假设状态全可知，使用**LQR方法**设计控制器，并讨论权重矩阵 `Q` 和 `R` 对性能的影响。~~

* ~~**理论关联**: 这直接应用**第8章 (Chapter 8: Quadratic Optimal Control)** 的理论。~~

* ~~**分析**:~~
  
  1. ~~**目标**: LQR不是直接“放置”极点，而是通过最小化一个二次型代价函数 `J = ∫(x'Qx + u'Ru)dt` 来寻找一个**最优**的反馈增益 `K`。~~
  2. ~~**Q和R的意义**: 这是此任务的核心。`Q` 是状态权重矩阵，`R` 是控制权重矩阵。它们的相对大小代表了您在“控制精度”和“控制成本”之间的权衡。~~
     * ~~**增大 `Q`**: 意味着您更不容忍状态 `x` 的偏差，控制器会变得更“激进”（`K` 的范数变大），系统响应更快，但控制输入 `u` 的幅值也会更大。~~
     * ~~**增大 `R`**: 意味着您希望节省控制能量（例如，执行器的动作幅度），控制器会变得更“温和”（`K` 的范数变小），系统响应变慢。~~
  3. ~~**设计流程**: 通过调整 `Q` 和 `R`（通常从对角阵开始尝试），反复仿真，直到系统的瞬态响应满足给定的超调和稳定时间要求，同时控制信号 `u` 的大小也处于一个“合理”的范围内。~~
1. **任务目标与LQR思想**
   任务二要求我们使用LQR方法设计一个状态反馈控制器 u = -Kx，并重点讨论权重矩阵 Q 和 R 对系统性能的影响。
   与任务一中我们“强行”指定极点位置不同，LQR是一种更“优雅”的最优控制方法。它的核心思想是在系统性能（响应速度、误差大小）和控制成本（能量消耗
   ）这对固有矛盾之间，寻找一个最佳的权衡（best trade-off） (参考 Chapter 8, Slide 4)。
   这种权衡是通过最小化一个二次型代价函数 (Cost Function) 来数学化实现的 (参考 Chapter 8, Slide 6, Eq. 2):<img title="" src="file:///C:/Users/16612/Pictures/Typedown/88fcab75-224b-4417-bed3-df78e6010d6b.png" alt="88fcab75-224b-4417-bed3-df78e6010d6b" style="zoom:33%;" data-align="center">
   
   $$
   J = \frac{1}{2}\int_{0}^{\infty} (x^T Q x + u^T R u) dt
   $$
   
   * $x^T Q x$ (状态惩罚项): 衡量了系统状态 x 偏离零点（平衡点）的代价。
   * $u^T R u$ (控制输入惩罚项): 衡量了使用控制输入 u 的代价。
   
   LQR的目标就是找到一个反馈增益 K，使得在这个 K 的作用下，总代价 J 达到最小值。

2. **如何完成任务二：详细设计流程**
   
   ### 步骤 2.1：LQR问题求解的理论基础
   
   * 思路: LQR理论提供了一个求解最优反馈增益 K 的标准方法。这个 K 并非凭空而来，而是通过求解一个关键的矩阵方程得到的。
   
   * 理论支撑:
     
     1. 代数黎卡提方程 (Algebraic Riccati Equation, ARE): 这是LQR问题的核心。我们需要求解一个唯一的、对称半正定的矩阵 P，它满足以下方程 (参考
         Chapter 8, Slide 38):<img title="" src="file:///C:/Users/16612/Pictures/Typedown/62b81296-1da2-4b85-a140-4a7b2d8b0452.png" alt="62b81296-1da2-4b85-a140-4a7b2d8b0452" style="zoom:50%;" data-align="center">
        
        $$
        A^TP + PA - PBR^{-1}B^TP + Q = 0
        $$
     
     2. 最优反馈增益 (Optimal Feedback Gain): 一旦解出矩阵 P，最优的反馈增益 K 就可以直接计算得出 (参考 Chapter 8, Slide 40):<img title="" src="file:///C:/Users/16612/Pictures/Typedown/24703c64-9cfd-4962-afb9-f721330991cc.png" alt="24703c64-9cfd-4962-afb9-f721330991cc" style="zoom:50%;" data-align="center">
        
        $$
        K = R^{-1}B^TP
        $$
   
   * 方法: 在MATLAB中，我们无需手动求解复杂的ARE方程。lqr 函数 K = lqr(A, B, Q, R) 封装了整个求解过程，是完成此步骤的直接工具。
   
   ### 步骤 2.2：选择权重矩阵 Q 和 R (设计的艺术与核心)
   
   这是任务二的精髓，因为它体现了控制工程师如何将抽象的性能要求转化为具体的数学参数。
   
   * 思路: 通过试凑法（trial-and-error）和对 Q、R 物理意义的理解，迭代调整这两个矩阵，直到闭环系统的性能满足要求。
   * 理论指导 (参考 Chapter 8, Slide 46-47):<img title="" src="file:///C:/Users/16612/Pictures/Typedown/e0e30a71-df9f-4f96-9c81-f4635b281ef8.png" alt="e0e30a71-df9f-4f96-9c81-f4635b281ef8" data-align="center" style="zoom:33%;"><img title="" src="file:///C:/Users/16612/Pictures/Typedown/2781b275-b42e-4798-ae2f-2364ce25f69d.png" alt="2781b275-b42e-4798-ae2f-2364ce25f69d" style="zoom:33%;" data-align="center">
     * `Q` 和 `R` 的结构: 通常选择为对角矩阵，这样可以独立地对每个状态变量的误差和每个控制输入的大小进行加权。
       * Q = diag([q1, q2, q3, q4])
       * R = diag([r1, r2])<img title="" src="file:///C:/Users/16612/Pictures/Typedown/7cc58358-d2b7-48e1-a154-39160808b9fc.png" alt="7cc58358-d2b7-48e1-a154-39160808b9fc" data-align="center" style="zoom:33%;">
     * `Q` 和 `R` 的性质: Q 必须是半正定矩阵 (Q >= 0)，R 必须是正定矩阵 (R > 0)，以保证代价函数有意义且控制信号有界 (参考 Chapter 8, Slide 7,
       21, 23)。<img title="" src="file:///C:/Users/16612/Pictures/Typedown/ac097ab0-d2e9-4b9a-a664-4cf3a71489e9.png" alt="ac097ab0-d2e9-4b9a-a664-4cf3a71489e9" data-align="center" style="zoom:33%;">
   * 迭代调整与讨论的策略:
     1. 设定初始值: 一个很好的起点是基于输出进行加权。因为我们最终关心的是输出 y，所以可以将状态惩罚 $x^T Q x$ 与输出惩罚 $y^T y$ 关联起来。由于
        $y = Cx$，我们有 $y^T y = x^T C^T C x$。因此，一个合理的初始选择是 $Q = C' * C$。对于控制惩罚，可以从 $R = I$ (单位矩阵)
        开始，这意味着对两个控制输入（VGT和EGR）的惩罚是均等的。
     
     > <mark>Q = C' * C中的C'是什么意思</mark>
     > 
     >  在MATLAB的语境中，以及在控制理论的文献中，当处理实数矩阵时，**C' 通常指的是矩阵的转置 (Transpose)**。
     > 
     >   详细解释
     > 
     > 1. 矩阵转置 (Transpose)：
     >    
     >    * 一个矩阵的转置，就是将其行和列互换。如果原始矩阵 C 的维度是 m x n，那么它的转置 C^T（在数学上通常用 T 上标表示）的维度就是 n x m。
     >    * 在我们的项目中，C 矩阵的维度是 2 x 4。
     >    * 因此，C' (即 C^T) 的维度就是 4 x 2。
     > 
     > 2. 为什么是 `Q = C' * C`：
     >    
     >    * 我们来检查一下矩阵乘法的维度：
     >      * C' 的维度是 4 x 2。
     >      * C 的维度是 2 x 4。
     >      * 所以，C' * C 的结果是一个 (4x2) * (2x4) = 4x4 的矩阵。
     >    * 这与状态惩罚矩阵 Q 的维度（必须是 n x n，即 4 x 4）完全匹配。
     > 
     > 3. 物理和数学意义：
     >    
     >    * 代价函数中的状态惩罚项是 x' * Q * x。
     >    * 如果我们选择 Q = C' * C，那么这一项就变成了 x' * (C' * C) * x。
     >    * 根据矩阵乘法律，这可以重写为 (C * x)' * (C * x)。
     >    * 我们知道，系统的输出 y = C * x。
     >    * 所以， (C * x)' * (C * x) 其实就是 y' * y，也就是输出向量 y 的欧几里得范数的平方 (||y||^2)。
     >    * 结论：选择 Q = C' * C 意味着我们不直接惩罚那四个没有物理意义的状态变量 `x`，而是直接惩罚我们关心的、有物理意义的输出
     >      `y`。我们希望输出 y（即AFR和EGR率）尽快回到零，所以我们把对 y 的惩罚作为代价函数的一部分。这是一种非常常见且直观的LQR权重选择方法。
     
     1. 分析与调整 (讨论的核心内容):
        * 场景一：响应太慢 (稳定时间不满足 < 5s)。
          * 原因: 对控制输入的惩罚 R 可能过高，或者对状态误差的惩罚 Q 不足。
          * 措施: 增大 $Q/R$ 的比值。可以尝试减小 R (例如 $R = 0.1*I$ 或 $R =
            0.01*I$)，这相当于“放松”了对控制能量的限制，允许控制器使用更大的力气。或者，增大 Q (例如 $Q = 10 *
            C'*C$)，告诉控制器“我更不能容忍状态误差”。
        * 场景二：超调太大或控制信号 `u` 峰值过高。
          * 原因: 控制器过于“激进”，对状态误差的反应过于灵敏。
          * 措施: 减小 $Q/R$ 的比值。可以尝试增大 R (例如 $R = 10*I$)，这相当于增加了控制成本，迫使控制器动作更“温和”。
     2. 记录与讨论: 您需要在报告中清晰地展示至少2-3组不同的 Q 和 R 组合及其对应的仿真结果（阶跃响应图和控制信号图）。然后，必须详细讨论这些变
        化如何导致了性能（响应速度、超调）和成本（控制信号幅值）之间的权衡，这直接对应了幻灯片Slide 4和Slide 47所阐述的核心思想。
   
   ### 步骤 2.3：最终验证
   
   * 思路: 当找到一组满意的 Q 和 R 后，进行最终的仿真验证，以证明其满足所有任务要求。
   * 方法:
     1. 使用最终计算出的 K 构建闭环系统 $sys_{cl-lqr} = ss(A-B*K, B, C, 0)$。
     2. 运行阶跃响应仿真，并从图中量化超调和稳定时间，确保它们满足 Mp < 10% 和 ts < 5s。
     3. 运行初始状态响应仿真，展示所有四个状态变量 x 和两个控制输入 u 的曲线。
     4. 将这些图表和最终选择的 Q, R 以及计算出的 K 矩阵作为任务二的最终设计成果。

---

#### **任务 3: 基于观测器的LQR控制**

任务原文要求：

* **要求**: 现实化一步，假设只有输出 `y` 可测，设计一个**状态观测器**来估计状态 `x̂`，并与任务2的LQR控制器结合。
* **理论关联**: 这是**第11章 (Chapter 11: State Estimation)** 和第8章的结合。
* **分析**:
  1. **动机**: 在实际中，所有状态变量往往不是都能直接测量的。观测器的作用就是根据已知的输入 `u` 和输出 `y` 来重构整个状态向量。
  2. **分离原理**: 第11章（Page 32）的核心是**分离原理**。它指出，控制器设计和观测器设计可以分开进行。整个闭环系统的极点集合是控制器极点 `eig(A-BK)` 和观测器极点 `eig(A-LC)` 的并集。
  3. **观测器设计**: 设计观测器就是设计其增益矩阵 `L`。这本质上也是一个极点配置问题，目标是配置观测器误差动态 `A-LC` 的极点。
  4. **观测器极点选择**: 为了让估计值 `x̂` 尽快收敛到真实值 `x`，观测器的动态通常要比控制器快。一个常用的经验法则是让观测器极点的实部是控制器主导极点实部的3到5倍。
  5. **关键前提**: 设计任意极点的观测器的前提是系统**可观**。因此，需要先检验 `(A, C)` 对的可观性。

---

#### **任务 4: 解耦控制器设计**

* **要求**: 设计一个控制器，实现输入输出间的**解耦**，并保证闭环稳定。
* **理论关联**: 这正是**第10章 (Chapter 10: Decoupling Control)** 的核心内容。
* **分析**:
  1. **目标**: 设计一个状态反馈控制器 `u = -Kx + Fr`，使得闭环传递函数矩阵 `H(s)` 是一个对角阵。这样，参考输入 `r1` 只影响输出 `y1`，`r2` 只影响 `y2`。
  2. **可解耦性判断**: 第10章（Page 20）给出了充要条件：**解耦矩阵 `B*` 必须是非奇异的**。计算 `B*` 需要先计算每个输出的**相对阶 `σ_i`**。这是此任务的第一个关键计算步骤。
  3. **控制器计算**: 如果 `B*` 非奇异，那么就可以根据第10章的公式（Page 20, Theorem 1 或 Page 33, Theorem 2）计算出实现解耦的 `K` 和 `F`。Theorem 2允许在解耦的同时配置极点，这对于满足项目的动态性能指标非常有用。
  4. **内部稳定性**: 项目特别提问“解耦后的系统是否内部稳定”。这提醒我们要检查在解耦过程中是否发生了不稳定的零极点对消。对于状态反馈解耦，如果原系统是可控可观的，通常可以保证内部稳定性。

---

#### **任务 5: 带扰动抑制的伺服控制**

* **要求**: 设计一个控制器，使得输出 `y` 能跟踪一个非零设定点 `ysp`，并且能抑制输入端的阶跃扰动 `w`。
* **理论关联**: 这完美契合**第9章 (Chapter 9: Servo Control)** 的内容。
* **分析**:
  1. **目标**: 实现零稳态误差的跟踪和抗扰。
  2. **内部模型原理**: 第9章的核心思想是**内部模型原理**。要消除阶跃信号（设定点和扰动都是阶跃类型）带来的稳态误差，控制器中必须包含一个积分器（其传递函数包含 `1/s` 极点）。
  3. **设计方法**: 通过引入一个新的状态变量，即误差的积分 `v = ∫(r-y)dt`，将原系统扩展为一个**增广系统**。然后，为这个新的、更高维度的增广系统设计一个状态反馈控制器。这个控制器天然地就包含了积分作用。
  4. **控制器形式**: 设计出的控制器形如 `u = -K1x - K2v`，其中 `-K2v` 项就是积分控制部分。
  5. **关键前提**: 增广系统必须是可控的。第9章（Page 58）给出了检验增广系统可控性的条件，即 `rank[A B; -C 0] = n+m`，其中n是原系统阶数，m是输出个数。这等价于原系统没有在 `s=0` 处的零点。

---

### 注意：

请注意，上述所有设计问题均无唯一答案。对于我们的任务，在理想情况下，控制输入可以视为无限量。但现实中所有物理执行器的驱动能力都存在限制。

作为控制系统设计工程师，您需要根据实际情况做出专业判断。

在控制器设计与论证过程中，需重点考量以下三大要素：

- 速度-瞬态响应

- 准确度——稳态误差

- 成本——控制信号的大小

<mark>！请按照 线性系统 的设计流程来解决上述所有问题。在报告中列出必要的公式和中间结果。如果只是调用MATLAB的内置函数进行控制系统设计而没有详细说明，例如，只是简单地用place来放置极点或者用lqr来设计LQR调节器，那么你将得到零分。！</mark>

---

### 报告格式要求 (Format of Reports)

根据 `dual_Mini-project-2025.pdf` 文件第5节的要求，您的报告应包含以下部分，并按此顺序组织：

* **封面页 (Cover Page)**: 标明 “Assignment for EE5101/ME5401 (or your specialization code if else) Linear Systems”, 自选报告标题, 您的姓名, 学号, 邮箱地址和日期。
* **摘要 (Abstract)**: 另起一页，50-100字。
* **目录 (Contents Table)**: 另起一页。
* **第一节：引言 (Section 1: Introduction)**
* **报告主体**: 分为几个有特定重点的章节，清晰地组织报告的主要内容。
  * 对所有方程式、表格和图表进行编号和添加标题。
  * 确保图表尺寸和质量足够高，便于结果验证。
* **结论 (Conclusions)**: 报告的最后一部分。
* **参考文献 (References)**: 如有引用，请列出。
* **附录 (Appendices)**:
  * MATLAB代码应放在附录中。
  * 如果使用Simulink，模型截图应作为插图插入报告主体的适当位置。

**其他重要提示**:

* 注意报告的整体呈现：英文写作、组织结构、布局等。
* 报告应正式、完整、可读性强。建议使用Word或LaTeX等文字处理软件。
* 内容为王，而非长度。报告应避免过多不必要的“复制粘贴”。

```Prompt
很好，现在在@Mini\ Project/目录下创建新的Task1_readme.md,文件内容包括详细的任务一要求，结合编写的代码以及使用到的Linear System的公式形成详细的报告，报告详细的要求如下：
1. 报告不能频繁的进行markdown分点，要符合学术论文的格式，主要以自然段的形式呈现
2. 报告分为四个部分：Introduction(介绍问题），Tasks Solvement(介绍tasks是如何按照Linear System的设计流程来解决的，对于task1主要参考chapter7文档。需要列出必要的公式以及相关的代码和中间结果，公式需要使用latex格式,代码需要具体指出对饮的代码，中间结果可以以截图或者文字的形式)，Discussion and Conclusion(简单的讲解一下收获)
```



---

### **总结**

这个项目设计得非常巧妙，每个任务都对应了您课程中的一个核心章节，构成了一个从基础到高级，从理想到实际的完整控制系统设计流程。

* **任务1/2** 是基础的状态反馈控制。
* **任务3** 考虑了状态不可测的实际情况，引入观测器。
* **任务4** 解决了MIMO系统特有的耦合问题。
* **任务5** 解决了控制系统最常见的两个实际需求：跟踪设定点和抑制扰动。

我的建议是，您可以按照任务的顺序，逐个攻破。在进行每个任务时，重点回顾对应章节的理论、公式和设计步骤。
